#! @BASH@

set -e

# File: backup-files.sh

# Copyright (C) 2006 Steve Langasek <vorlon@debian.org>
# portions Copyright (C) 2003, 2004, 2005, 2006 Andreas Gruenbacher
# <agruen@suse.de>, SuSE Labs

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program;  if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.


# Create backup files of a list of files similar to GNU patch. A path
# name prefix for the backup files must be specified with the -B option.

usage () {
	echo "Usage: $0 -B prefix [-s] [-k] [-t] [-L] [-b|-r|-c|-x] {-f {file|-}|-|file ...}

	Create or restore backup copies of a list of files.

	-b	Create backup
	-r	Restore the backup
	-c	Create simple copy
	-x	Remove backup files and empty parent directories
	-k	When doing a restore, keep the backup files
	-B	Path name prefix for backup files
	-s	Silent operation; only print error messages
	-f	Read the filenames to process from file (- = standard input)
	-t	Touch original files after restore (update their mtimes)

	-L	Ensure that when finished, the source file has a link count of 1
"
}

: ${QUILT_DIR=@QUILT_DIR@}
. $QUILT_DIR/scripts/utilfns

ensure_nolinks() {
	local filename=$1
	local link_count tmpname

	link_count=$(stat @STAT_HARDLINK@ "$filename")
	if [ $link_count -gt 1 ]; then
		tmpname=$(mktemp "$filename.XXXXXX")
		cp -p "$filename" "$tmpname"
		mv "$tmpname" "$filename"
	fi
}

backup() {
	local file=$1
	local backup=$OPT_PREFIX$file
	local dir

	dir=$(dirname "$backup")
	[ -d "$dir" ] || mkdir -p "$dir"

	if [ -e "$file" ]; then
		$ECHO "Copying $file"
		if [ -n "$OPT_NOLINKS" -a "$(stat @STAT_HARDLINK@ "$file")" = 1 ]; then
			cp -p "$file" "$backup"
		else
			ln "$file" "$backup" 2> /dev/null || cp -p "$file" "$backup"
			if [ -n "$OPT_NOLINKS" ]; then
				ensure_nolinks "$file"
			fi
		fi
	else
		$ECHO "New file $file"
		: > "$backup"
	fi
}

# Same as restore, but assume that required directories are already
# created, target files are already removed, and don't bother removing
# the backup files or touching target files after restoration.
restore_fast()
{
	local file=$1
	local backup=$OPT_PREFIX$file

	if [ -s "$backup" ]; then
		$ECHO "Restoring $file"
		if [ -n "$OPT_NOLINKS" ]; then
			cp -p "$backup" "$file"
		else
			ln "$backup" "$file" 2> /dev/null || cp -p "$backup" "$file"
		fi
	else
		$ECHO "Removing $file"
	fi
}

restore()
{
	local file=$1
	local backup=$OPT_PREFIX$file

	if [ ! -e "$backup" ]; then
		return 1
	fi
	if [ -s "$backup" ]; then
		$ECHO "Restoring $file"
		if [ -e "$file" ]; then
			rm "$file"
		else
			mkdir -p "$(dirname "$file")"
		fi
		if [ -n "$OPT_NOLINKS" ]; then
			cp -p "$backup" "$file"
		else
			ln "$backup" "$file" 2> /dev/null || cp -p "$backup" "$file"
		fi

		if [ -n "$OPT_TOUCH" ]; then
			touch "$file"
		fi
	else
		$ECHO "Removing $file"
		if [ -e "$file" ]; then
			rm "$file"
		fi
	fi

	if [ -z "$OPT_KEEP_BACKUP" ]; then
		rm "$backup"
		rmdir -p "${backup%/*}" 2> /dev/null || true
	fi
}

restore_all()
{
	local EMPTY_FILES NONEMPTY_FILES

	# Store the list of files to process
	EMPTY_FILES=$(gen_tempfile)
	NONEMPTY_FILES=$(gen_tempfile)
	trap "rm -f \"$EMPTY_FILES\" \"$NONEMPTY_FILES\"" EXIT

	cd "$OPT_PREFIX"
	find . -type f -size 0 -print0 > "$EMPTY_FILES"
	find . -type f -size +0 -print0 > "$NONEMPTY_FILES"
	cd "$OLDPWD"

	if [ -s "$EMPTY_FILES" ]; then
		xargs -0 rm -f < "$EMPTY_FILES"

		while read -d $'\0' -r
		do
			restore_fast "${REPLY#./}"
		done < "$EMPTY_FILES"
	fi

	if [ -s "$NONEMPTY_FILES" ]; then
		# Try a mass link (or copy) first, as it is much faster.
		# It is however not portable and may thus fail. If it fails,
		# fallback to per-file processing, which always works.
		local target_dir=$PWD opt_l=-l
		[ -n "$OPT_NOLINKS" ] && opt_l=-p

		if (cd "$OPT_PREFIX" && \
		    xargs -0 cp $opt_l --parents --remove-destination \
				--target-directory="$target_dir" \
				< "$NONEMPTY_FILES" 2> /dev/null); then
			while read -d $'\0' -r
			do
				$ECHO "Restoring ${REPLY#./}"
			done < "$NONEMPTY_FILES"
		else
			(cd "$OPT_PREFIX" && find . -type d -print0) \
			| xargs -0 mkdir -p

			xargs -0 rm -f < "$NONEMPTY_FILES"

			while read -d $'\0' -r
			do
				restore_fast "${REPLY#./}"
			done < "$NONEMPTY_FILES"
		fi

		if [ -n "$OPT_TOUCH" ]; then
			xargs -0 touch -c < "$NONEMPTY_FILES"
		fi
	fi

	if [ -z "$OPT_KEEP_BACKUP" ]; then
		rm -rf "$OPT_PREFIX"
	fi
}

remove()
{
	local file=$1
	local backup=$OPT_PREFIX$file

	if [ -e "$backup" ]; then
		rm "$backup"
	fi
	rmdir -p "${backup%/*}" 2> /dev/null || true
}

noop_nolinks()
{
	local file=$1

	if [ -e "$file" ]; then
		ensure_nolinks "$file"
	fi
}

copy()
{
	local file=$1
	local backup=$OPT_PREFIX$file
	local dir

	dir=$(dirname "$backup")
	[ -d "$dir" ] || mkdir -p "$dir"

	if [ -e "$file" ]; then
		$ECHO "Copying $file"
		cp -p "$file" "$backup"
	else
		$ECHO "New file $file"
		: > "$backup"
	fi
}

copy_many()
{
	local NONEMPTY_FILES

	# Store the list of non-empty files to process
	NONEMPTY_FILES=$(gen_tempfile)
	trap "rm -f \"$NONEMPTY_FILES\"" EXIT

	# Keep the temporary file opened to speed up the loop
	exec 3> "$NONEMPTY_FILES"
	cat "$OPT_FILE" \
	| while read
	do
		if [ -e "$REPLY" ]; then
			printf '%s\0' "$REPLY" >&3
		else
			# This is a rare case, not worth optimizing
			copy "$REPLY"
		fi
	done
	exec 3>&-

	while read -d $'\0' -r
	do
		copy "$REPLY"
	done < "$NONEMPTY_FILES"
}

# Test if some backed up files have a link count greater than 1
some_files_have_links()
{
	(cd "$OPT_PREFIX" && find . -type f -print0) \
	| xargs -0 stat @STAT_HARDLINK@ 2> /dev/null | grep -qv '^1$'
}


ECHO=echo
while [ $# -gt 0 ]; do
	case $1 in
	-b)	OPT_WHAT=backup
		;;
	-r)	OPT_WHAT=restore
		;;
	-c)	OPT_WHAT=copy
		;;
	-x)	OPT_WHAT=remove
		;;
	-B)	OPT_PREFIX=$2
		shift
		;;
	-f)	OPT_FILE=$2
		shift
		;;
	-s)	ECHO=:
		;;
	-k)	OPT_KEEP_BACKUP=1
		;;
	-L)	OPT_NOLINKS=1
		;;
	-t)	OPT_TOUCH=1
		;;
	-?*)	usage
		exit 0
		;;
	*)	break
		;;
	esac

	shift
done

if [ -z "$OPT_PREFIX" ]; then
	usage
	exit 1
fi

if [ "${OPT_PREFIX:(-1)}" != / ]; then
	echo "Prefix must be a directory" >&2
	exit 1
fi

if [ -z "$OPT_WHAT" ]; then
	if [ -n "$OPT_NOLINKS" ]; then
		OPT_WHAT=noop_nolinks
	else
		exit 0
	fi
fi

if [ -n "$OPT_FILE" ]; then
	if [ "$OPT_WHAT" = copy ]; then
		copy_many
		exit
	fi

	cat "$OPT_FILE" \
	| while read nextfile; do
		$OPT_WHAT "$nextfile"
	done
	exit
fi

if [ "$1" = - ]; then
	# No backup directory? We're done
	[ -d "$OPT_PREFIX" ] || exit 0

	if [ "$OPT_WHAT" = restore ]; then
		restore_all
		exit
	fi

	# We typically expect the link count of backed up files to be 1
	# already, so check quickly that this is the case, and only if not,
	# take the slow path and walk the file list in search of files to fix.
	if [ "$OPT_WHAT" = noop_nolinks ] && ! some_files_have_links; then
		exit
	fi

	find "$OPT_PREFIX" -type f -print \
	| while read
	do
		$OPT_WHAT "${REPLY#$OPT_PREFIX}"
	done
	if [ ${PIPESTATUS[0]} != 0 ]; then
		exit 1
	fi
	exit
fi

while [ $# -gt 0 ]; do
	$OPT_WHAT "$1"
	shift
done
