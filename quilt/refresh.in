#! @BASH@

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  See the COPYING and AUTHORS files for more details.

# Read in library functions
if [ "$(type -t patch_file_name)" != function ]
then
	if ! [ -r @SCRIPTS@/patchfns ]
	then
		echo "Cannot read library @SCRIPTS@/patchfns" >&2
		exit 1
	fi
	. @SCRIPTS@/patchfns
fi

usage()
{
	local redirect
	if [ x$1 != x-h ]
	then
		redirect='>&2'
	fi
	echo $"Usage: quilt refresh [-p n] [-f] [patch]" $redirect
	
	if [ x$1 = x-h ]
	then
		echo $"

Refreshes the specified patch, or the topmost patch by default.
Documentation that comes before the actual patch in the patch file is
retained.

It is possible to refresh patches that are not on top.  If any patches
on top of the patch to refresh modify the same files, the script aborts
by default.  Patches can still be refreshed with -f.  In that case this
script will print a warning for each shadowed file, changes by more
recent patches will be ignored, and only changes in files that have not
been modified by any more recent patches will end up in the specified
patch.

-p n	Create a -p n style patch (-p0 or -p1 supported).
	
-f	Force refresh, even if more recent patches modify
	some of the same files.

"
		exit 0
	else
		exit 1
	fi
}

die ()
{
	local status=$1
	[ -n "$tmpfile" ] && rm -f $tmpfile
	[ -n "$tmpfile2" ] && rm -f $tmpfile2
	exit $status
}

options=`getopt -o p:fh -- "$@"`

if [ $? -ne 0 ]
then
	usage
fi

eval set -- "$options"

while true
do
	case "$1" in
	-p)
		opt_strip_level=$2
		shift 2 ;;
	-f)
		opt_force=1
		shift ;;
	-h)
		usage -h ;;
	--)
		shift
		break ;;
	esac
done

if [ $# -eq 1 ]
then
	opt_patch=$1
elif [ $# -gt 1 ]
then
	usage
fi

if [ -n "$opt_patch" ]
then
	patch=$(stripit $opt_patch)
else
	patch=$(top_patch)
	if [ -z "$patch" ]
	then
		echo $"No patch seem to be applied" >&2
		exit 1
	fi
fi

if ! is_applied "$patch"
then
	echo $"Patch $patch is not applied" >&2
	exit 1
fi

if [ -z "$opt_strip_level" ]
then
	opt_strip_level=$(patch_strip_level $patch)
fi
if [ $opt_strip_level -gt 1 ]
then
	echo $"Cannot refresh patches with -p$opt_strip_level, please specify -p0 or -p1 instead" >&2
	exit 1
fi

trap "die 1" SIGTERM

tmpfile=$(gen_tempfile)

for file in $(files_in_patch $patch)
do
	old_file=$(backup_file_name $patch $file)
	next_patch=$(next_patch_for_file $patch $file)
	if [ -z "$next_patch" ]
	then
		new_file=$file
	else
		new_file=$(backup_file_name $next_patch $file)
		files_were_shadowed=1
	fi
	if ! diff_file $file $old_file $new_file >> $tmpfile
	then
		echo $"Diff failed, aborting." >&2
		die 1
	fi

	if [ -n "$files_were_shadowed" -a -z "$opt_force" ]
	then
		echo $"More recent patches modify files in $patch. Enforce refresh with -f." >&2
		die 1
	fi
done

if ! [ -s $tmpfile ]
then
	echo $"Nothing in patch $patch" >&2
	die 1
fi

patch_file=$(patch_file_name $patch)

trap "" SIGINT

if [ -e $patch_file ] && grep -q '^%patch$' $patch_file
then
	if [ -x "@DIFFSTAT@" ]
	then
		@DIFFSTAT@ $tmpfile 2>/dev/null \
		| @SCRIPTS@/parse-patch -u diffstat $patch_file
	fi
	cat $tmpfile \
	| @SCRIPTS@/parse-patch -u patch $patch_file
else
	if ! tmpfile2=$(gen_tempfile)
	then
		die 1
	fi

	mkdir -p $(dirname $patch_file)

	if ! cat_file $patch_file \
	     | patch_description > $tmpfile2 || \
	   ! cat $tmpfile >> $tmpfile2 || \
	   ! cat $tmpfile2 \
	     | cat_to_file $patch_file
	then
		die 1
	fi
fi
if [ $? -ne 0 ]
then
	die 1
fi

rm -f $(pc_file_name $patch)~refresh
echo $"Refreshed patch $patch"
if ! change_db_strip_level -p$opt_strip_level $patch
then
	die 1
fi
die 0
### Local Variables:
### mode: shell-script
### End:
# vim:filetype=sh
