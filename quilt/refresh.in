#! @BASH@

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  See the COPYING and AUTHORS files for more details.

# Read in library functions
if [ "$(type -t patch_file_name)" != function ]
then
	if ! [ -r @SCRIPTS@/patchfns ]
	then
		echo "Cannot read library @SCRIPTS@/patchfns" >&2
		exit 1
	fi
	. @SCRIPTS@/patchfns
fi

usage()
{
	echo $"Usage: quilt refresh [-p n] [-f] [--no-timestamps] [--backup] [patch]"
	
	if [ x$1 = x-h ]
	then
		echo $"
Refreshes the specified patch, or the topmost patch by default.
Documentation that comes before the actual patch in the patch file is
retained.

It is possible to refresh patches that are not on top.  If any patches
on top of the patch to refresh modify the same files, the script aborts
by default.  Patches can still be refreshed with -f.  In that case this
script will print a warning for each shadowed file, changes by more
recent patches will be ignored, and only changes in files that have not
been modified by any more recent patches will end up in the specified
patch.

-p n	Create a -p n style patch (-p0 or -p1 supported).

-f	Force refresh, even if more recent patches modify
	some of the same files.

--no-timestamps
	Do not include file timestamps in patch headers.
	
--backup
	Create a backup copy of the old version of a patch as patch~."
		exit 0
	else
		exit 1
	fi
}

die ()
{
	local status=$1
	[ -n "$tmpfile" ] && rm -f $tmpfile
	[ -n "$tmpfile2" ] && rm -f $tmpfile2
	exit $status
}

options=`getopt -o p:fh --long no-timestamps,backup -- "$@"`

if [ $? -ne 0 ]
then
	usage
fi

eval set -- "$options"

while true
do
	case "$1" in
	-p)
		opt_strip_level=$2
		shift 2 ;;
	-f)
		opt_force=1
		shift ;;
	-h)
		usage -h ;;
	--no-timestamps)
		QUILT_NO_DIFF_TIMESTAMPS=1
		shift ;;
	--backup)
		QUILT_BACKUP=1
		shift ;;
	--)
		shift
		break ;;
	esac
done

if [ $# -eq 1 ]
then
	opt_patch=$1
elif [ $# -gt 1 ]
then
	usage
fi

if [ -n "$opt_patch" ]
then
	if ! patch=$(find_patch $opt_patch)
	then
		echo $"Patch $opt_patch is not in series" >&2
		exit 1
	fi
	if ! is_applied "$patch"
	then
		echo $"Patch $patch is not applied" >&2
		exit 1
	fi
else
	patch=$(top_patch)
	if [ -z "$patch" ]
	then
		echo $"No patches applied" >&2
		exit 1
	fi
fi

if [ -z "$opt_strip_level" ]
then
	opt_strip_level=$(patch_strip_level $patch)
fi
if [ $opt_strip_level -gt 1 ]
then
	echo $"Cannot refresh patches with -p$opt_strip_level, please specify -p0 or -p1 instead" >&2
	exit 1
fi

trap "die 1" SIGTERM

tmpfile=$(gen_tempfile)

for file in $(files_in_patch_ordered $patch)
do
	old_file=$(backup_file_name $patch $file)
	next_patch=$(next_patch_for_file $patch $file)
	if [ -z "$next_patch" ]
	then
		new_file=$file
	else
		new_file=$(backup_file_name $next_patch $file)
		files_were_shadowed=1
	fi
	if ! diff_file $file $old_file $new_file >> $tmpfile
	then
		echo $"Diff failed, aborting." >&2
		die 1
	fi

	if [ -n "$files_were_shadowed" -a -z "$opt_force" ]
	then
		echo $"More recent patches modify files in $patch. Enforce refresh with -f." >&2
		die 1
	fi
done

if ! [ -s $tmpfile ]
then
	echo $"Nothing in patch $patch" >&2
	die 1
fi

patch_file=$(patch_file_name $patch)

trap "" SIGINT

if ! tmpfile2=$(gen_tempfile)
then
	die 1
fi

mkdir -p $(dirname $patch_file)

if ! cat_file $patch_file \
     | patch_description > $tmpfile2 || \
   ! cat $tmpfile >> $tmpfile2
then
	die 1
fi

if [ -e $patch_file ] && \
   @DIFF@ -q $patch_file $tmpfile2 > /dev/null
then
	echo $"Patch $patch is unchanged"
	exit 0
fi

if ( [ -n "$QUILT_BACKUP" -a -e $patch_file ] && \
     ! cp $patch_file $patch_file~ ) || \
   ! cat_to_file $patch_file < $tmpfile2
then
	die 1
fi

touch $QUILT_PC/$patch/.timestamp

rm -f $QUILT_PC/$patch~refresh
echo $"Refreshed patch $patch"
if ! change_db_strip_level -p$opt_strip_level $patch
then
	die 1
fi
die 0
### Local Variables:
### mode: shell-script
### End:
# vim:filetype=sh
