#! @BASH@

#  This script is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.
#
#  See the COPYING and AUTHORS files for more details.

# Read in library functions
if [ "$(type -t patch_file_name)" != function ]
then
	if ! [ -r @SCRIPTS@/patchfns ]
	then
		echo "Cannot read library @SCRIPTS@/patchfns" >&2
		exit 1
	fi
	. @SCRIPTS@/patchfns
fi

usage()
{
	printf $"Usage: $0 [-fRq] patchname\n"
	exit 1
}

files_may_have_changed()
{
	local patch=$1 file
	local patch_file=$(patch_file_name $patch)
	
	if [ $? -ne 0 -o ! -e "$patch_file" \
	     -o ! -e "$QUILT_PC/$patch/.timestamp" \
	     -o "$QUILT_PC/$patch/.timestamp" -ot "$patch_file" ]
	then
		return 0
	fi
	
	local apply_ts=$(date -r "$QUILT_PC/$patch/.timestamp" '+%s') ts
	for file in $(files_in_patch $patch)
	do
		ts=$(date -r $file '+%s' 2> /dev/null)
		[ -z "$ts" ] && return 0
		[ "$ts" -gt $apply_ts ] && return 0
	done
	return 1
}

# Check if all changes have been folded back into the patch (quilt refresh),
# and report any pending changes.
check_for_pending_changes()
{
	local patch=$1
	local patch_file=$(patch_file_name $patch)
	local patch_args=$(patch_args $patch)
	local workdir=$(gen_tempfile -d quilt) status=0

	if [ -d $QUILT_PC/$patch ]
	then
		if ! rmdir $workdir ||  # note that this is racey...
		   ! cp -rl $QUILT_PC/$patch $workdir/
		then
			printf $"Failed to copy files to temporary directory\n" >&2
			rm -rf $workdir
			return 1
		fi

		# Now we may have some zero-size files that have no
		# permissions (which represent files that the patch
		# creates). Those may have been created in the meantime,
		# but patch would refuse to touch them: We must remove
		# them here.
		find $workdir -type f -size 0 -exec rm -f '{}' ';'

	fi
	
	if [ -s $patch_file ]
	then
		if ! cat_file $patch_file \
		     | @PATCH@ -d $workdir $patch_args \
			       --no-backup-if-mismatch -E \
			       >/dev/null 2>/dev/null
		then
			if ! [ -e $QUILT_PC/$patch ]
			then
				printf $"Failed to patch temporary files\n" >&2
				rm -rf $workdir
				return 1
			fi
		fi
	fi
	
	local remains=$(gen_tempfile)
	for file in $(files_in_patch $patch)
	do
		diff_file $file $workdir/$file $file >> $remains
	done
	
	if [ -s $remains ]
	then
		printf $"Patch %s does not remove cleanly (enforce with -f)\n" \
		       "$(print_patch $patch)" >&2
		status=1
	fi
	rm -f $remains
	rm -rf $workdir

	return $status
}

rpatch()
{
	local patch=$1 status=0

	trap "" SIGINT
	if [ -z "$opt_force" ] && \
	   ( [ -n "$opt_remove" ] || files_may_have_changed $patch )
	then
		check_for_pending_changes $patch || status=1
	fi

	if [ $status -eq 0 ]
	then
		printf $"Removing patch %s\n" "$(print_patch $patch)"
		rm -f "$QUILT_PC/$patch/.timestamp"
		@LIB@/backup-files $silent -r -B $QUILT_PC/$patch/ -
		status=$?
		remove_from_db $patch
		rm -f $QUILT_PC/$patch~refresh
	fi
	trap - SIGINT
	return $status
}

options=`getopt -o fRqvh -- "$@"`

if [ $? -ne 0 ]
then
	usage
fi

eval set -- "$options"

while true
do
	case "$1" in
	-f)
		opt_force=1
		shift ;;
	-R)
		opt_remove=1  # remove properly with patch -R; no tricks
		unset opt_force
		shift ;;
	-q)
		opt_quiet=1 
		shift ;;
	-v)
		opt_verbose=1
		shift ;;
	-h)
		usage -h ;;
	--)
		shift
		break ;;
	esac
done

if [ $# -ne 1 ]
then
	usage
fi

patch=$1
[ -n "$opt_quiet" ] && silent=-s
[ -z "$opt_verbose" ] && silent_unless_verbose=-s

top=$(top_patch)
if [ -n "$top" -a -e $QUILT_PC/$top~refresh -a -z "$opt_force" ]
then
	printf $"Patch %s needs to be refreshed first.\n" \
	       "$(print_patch $top)" >&2
	exit 1
fi

rpatch "$patch" || exit 1
### Local Variables:
### mode: shell-script
### End:
# vim:filetype=sh
